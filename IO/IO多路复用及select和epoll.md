# IO多路复用及select和epoll

参考：https://blog.csdn.net/davidsguo008/article/details/73556811

https://blog.csdn.net/sehanlingfeng/article/details/78920423

**<font color='#02C874' size=4>注意，这不是多线程，可以说是单线程的“多路复用”</font>**

------



## 什么是多路复用？

> <font color='red' size = 4>***IO多路复用模型是建立在内核提供的==多路分离函数select==基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。***</font>

> <font color='red' size = 4>***用户首先将需要监听的描述符（IO请求）添加到select，当select一旦监听到某个描述符到条件满足，对应描述符（IO请求）被激活。达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。***</font>

------

## select、epoll

- select：
  - **将文件描述符放入一个集合中，调用select时，将这个集合从==用户空间拷贝到内核空间==（缺点1：每次都要复制，开销大）**；
  - ==采用水平触发机制==。select函数返回后，需要通过==遍历这个集合，找到就绪的文件描述符==（缺点3：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降；
- poll：==和select几乎没有区别==，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；
- epoll：
  - 通过==**内核和用户空间共享内存，避免了不断复制的问题**==；
  - 支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；
  - ==**文件描述符就绪时，采用回调机制，避免了轮询**==（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；
  - 支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。

------

## 水平触发与边缘触发

> 1. 水平触发level trigger LT（状态达到）
>
> 　　当被监控的文件描述符上有可读写事件发生时，会通知用户程序去读写，<font color='red'>**如果用户一次读写没取完数据，他会一直通知用户，如果这个描述符是用户不关心的，它每次都返回通知用户，则会导致用户对于关心的描述符的处理效率降低。**</font>
>
> 　　复用型IO中的select和poll都是使用的水平触发方式。
>
> 2. 边缘触发edge trigger ET（状态改变）
>
> 　　当被监控的文件描述符上有可读写事件发生时，会通知用户程序去读写，<font color='red'>**它只会通知用户进程一次，这需要用户一次把内容读取玩，相对于水平触发，效率更高。如果用户一次没有读完数据，再次请求时，不会立即返回，需要等待下一次的新的数据到来时才会返回，这次返回的内容包括上次未取完的数据。**</font>
>
> 　　信号驱动型IO使用的是边缘触发方式。
>
> 　　epoll既支持水平触发也支持边缘触发，默认是水平触发。
>
> 3. 比较
>
> 　　水平触发是状态达到后，可以多次取数据。这种模式下要注意多次读写的情况下，效率和资源利用率情况。
>
> ​    边缘触发是状态改变一次，取一次数据。这种模式下读写数据要注意一次是否能读写完成。

