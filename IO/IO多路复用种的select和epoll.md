# IO多路复用种的select和epoll

参考：https://blog.csdn.net/davidsguo008/article/details/73556811

**<font color='blue' size=5>注意，这不是多线程，可以说是单线程的“多路复用”</font>**

## Select

**select的缺点：**

- **==单个进程==能够监视的文件描述符的数量存在最大限制**，通常是1024，当然可以更改数量。**但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差**；

- 内核 / 用户空间内存拷贝问题，**select需要复制大量的句柄数据结构，产生巨大的开销**；
- select返回的是含有整个句柄的数组，应用程序需要**==遍历整个数组==才能发现哪些句柄发生了事件；**
- **select的触发方式是水平触发**，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。
- 相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。

拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。**==除了进程间上下文切换的时间消耗外，从内核/用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。==**因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。**<font color='red'>所以select是低并发的。</font>**

因此，该epoll上场了。



------

## epoll

**<font color='red'>epoll在内核中会维护一个红黑树和一个双向链表</font>**，红黑树存放通过epoll_ctl方法向epoll对象中添加进来的事件，所以不需要每次调用epoll_wait都全量复制所有的事件结构。

**<font color='red'>双向链表存放就绪的事件，所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系</font>**，也就是说，当相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。调用epoll_wait就会直接返回链表中的就绪事件，效率高。

**<font color='red'>select适合少量活跃连接，一般几千。</font>**

**<font color='red'>epoll适合大量不太活跃的连接。</font>**

**<font color='red'>如果有大量活跃连接可以使用多进程+select。</font>**