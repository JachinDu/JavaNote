# 垃圾收集算法



> 1. 标记-清除
> 2. 标记-整理
> 3. 复制
> 4. 分代收集



## 1、为什么要分代？

**在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**



## 2、垃圾收集器

![image-20191218191507014](../PicSource/image-20191218191507014.png)



> 1. **Serial：==新生代--复制；老年代--标整==**
>
>    ![image-20191218191613189](../PicSource/image-20191218191613189.png)
>
> 2. **ParNew：同Serial，多线程**
>
>    ![image-20191218191728896](../PicSource/image-20191218191728896.png)
>
> 3. **Parallel Scavenge ：类似ParNew，==但注重吞吐量(CPU利用率)==**
>
>    ![image-20191218191950350](../PicSource/image-20191218191950350.png)
>
> 4. **Serial Old：Serial 收集器的老年代版本**
>
> 5. **Parallel Old：Parallel Scavenge 收集器的老年代版本**
>
> 6. **CMS：以获取==最短回收停顿时间==为目标的收集器。** **==标记-清除==**
>
>    <font color='blue'>**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**</font>
>
>    ![image-20191218192320857](../PicSource/image-20191218192320857.png)
>
>    ------
>
>    - **初始标记：** ==暂停所有的其他线程==，并记录下==直接与 root 相连==的对象，速度很快 ；
>    - **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
>    - **重新标记：** 重新标记阶段就是为了==修正并发标记期间因为用户程序继续运行而导致标记产生变动==的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
>    - **并发清除：** 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。
>
>    **==缺点==：**
>
>    - **对 CPU 资源敏感；**
>    - **无法处理浮动垃圾；**
>    - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**
>
> 7. **G1收集器**：**==标整==**
>
>    **<font color='blue'>是一款面向服务器的垃圾收集器,主要针对配备==多颗处理器==及==大容量内存==的机器. 以极高概率==满足 GC 停顿时间==要求的同时,还具备高==吞吐量==性能特征.</font>**
>
>    - **初始标记**
>    - **并发标记**
>    - **最终标记**
>    - **筛选回收**
>
>    

