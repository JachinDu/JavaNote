# Synchronized与四种锁状态



## 1、Synchronized简介

### 1）对象头

![img](../PicSource/640-20200108111040166.jpeg)

------



## 2）Monitor对象（监视器锁）

监视器主要功能是监控一段代码，确保在同一时间只有一个线程在执行。

> <font color='#02C874'>***每个监视器都与一个对象相关联。当线程执行到监视器监视下的代码块中的第一条指令时，线程必须获取对被引用对象的锁定。在线程获取锁之前，他是无法执行这段代码的，一旦获得锁，线程便可以进入“被保护”的代码开始执行。当线程离开代码块的时候，无论如何离开，都会释放所关联对象的锁。***</font>

------

## 3）Synchronized同步方式（方法同步与代码块同步）

每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行`monitorenter`）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行`monitorexit`指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。



> - ### 方法同步：JVM采用==`ACC_SYNCHRONIZED`==标记符来实现同步。
>
>   方法级的同步是隐式的。同步方法的常量池中会有一个`ACC_SYNCHRONIZED`标志。<font color='#02C874'>**当某个线程要访问某个方法的时候，会检查是否有`ACC_SYNCHRONIZED`，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。**</font>值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。
>
> - ### 代码块同步：同步代码块使用==`monitorenter`==和==`monitorexit`==两个指令实现
>
>   <font color='#02C874'>**可以把执行`monitorenter`指令理解为加锁，执行`monitorexit`理解为释放锁。 **</font>

------



## 4）四种锁状态



![image-20200108131729480](../PicSource/image-20200108131729480.png)

> 注意：
>
> - **偏向锁**：
>
>   引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，**<font color='red'>因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在==置换ThreadID==的时候依赖一次CAS原子指令即可。每次线程获取锁时都通过mark word字段中的线程ID是不是自己，如果是，则直接获取进入，无需cas操作。</font>**
>
> - **轻量级锁**：==不阻塞==
>
>   1. 与偏向锁不同的就是，==***就算是同一线程重入，也要cas。***==
>   2. 若只有一个线程等待获取资源，那么==该线程自旋==，==自旋一定次数后还未获得锁则 &rArr; 重量级锁。==
>   3. <font color='red'>若已有一个线程在自旋等待，==此时又来一个线程，则 &rArr; 重量级锁。==</font>
> - **重量级锁：**
>
>   获取失败要==阻塞==

锁膨胀过程：

https://juejin.im/post/5c936018f265da60ec281bcb

![img](../PicSource/e0e01e43gy1g1cozajzz3j22zf1e7u0x.jpg)