# Synchronized与四种锁状态



## 1、Synchronized简介

### 1）对象头

![img](/Users/jc/Documents/JavaNote/并发编程/640-20200108111040166.jpeg)



## 2）Monitor对象

什么是Monitor？<font color='red'>我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象</font>。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，<font color='red'>每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</font>

每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的。



## 3）四种锁状态



![image-20200108131729480](/Users/jc/Documents/JavaNote/并发编程/image-20200108131729480.png)

> 注意：
>
> **偏向锁**：
>
> ​		引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，**<font color='red'>因为轻量级锁的获取		及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。每次线程获取锁时都通过mark word字段中的线程ID是不是自己，如果是，则直接获取进入，无需cas操作。</font>**
>
> **轻量级锁**：不阻塞
>
> 1. 与偏向锁不同的就是，==就算是同一线程重入，也要cas。==
>
> 2. 若只有一个线程等待获取资源，那么该线程自旋，==自旋一定次数后还未获得锁则----->重量级锁。==
>
> 3. 若已有一个线程在自旋等待，==此时又来一个线程，则----->重量级锁。==
>
> **重量级锁：**
>
> 获取失败要==阻塞==