# 并发队列

## &sect; 分类与简介

![image-20200211222957119](../PicSource/image-20200211222957119.png)

------

![image-20200211223414267](../PicSource/image-20200211223414267.png)



## &sect; LinkedBlockingQueue

### &sect; 构成

> - 底层为链表
>
> - put锁和take锁
>
> - notEmpty条件和notFull条件，使线程在对应条件等待
>
>   ```java
>   private final Condition notEmpty = takeLock.newCondition();
>   private final ReentrantLock putLock = new ReentrantLock();
>   ```
>
>   锁有 take 锁和 put 锁，是为了保证队列操作时的线程安全，设计两种锁，是为了 take 和 put 两种操作可以同时进行，互不影响。

------

### &sect; 阻塞添加

新增有多种方法，如：add、put、offer，三者的区别上文有说。我们拿 put 方法为例，put 方法在碰到队列满的时候，会一直阻塞下去，直到队列不满时，并且自己被唤醒时，才会继续去执行，源码如下：

> 1. 往队列新增数据，**==第一步是上锁，所以新增数据是线程安全的；==**
> 2. 队列新增数据，简单的**==追加到链表的尾部==**即可；
> 3. 新增时，如果**==队列满了，当前线程是会被阻塞的==**，阻塞的底层使用是锁的能力，底层实现其它也和队列相关；
> 4. 新增数据成功后，在适当时机，会**==唤起 put 的等待线程（队列不满时），或者 take 的等待线程（队列不为空时）==**，这样保证队列一旦满足 put 或者 take 条件时，立马就能唤起阻塞线程，继续运行，保证了唤起的时机不被浪费。

------

### &sect; 阻塞删除

以take为例，整体流程和 put 很相似，都是先上锁，然后从队列的头部拿出数据，==如果队列为空，会一直阻塞到队列有值为止。==