# 索引

内容在：https://juejin.im/post/5b55b842f265da0f9e589e79

<font color='gree' size = 5>***作用：可以大大加快数据的检索速度***</font>



#### **题目**：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？

#### **出题人**：阿里巴巴出题专家：近秋／阿里云数据库产品技术部技术专家

#### **参考答案**：<font color='red'>key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率。</font>



## &sect; 联合索引与最左前缀匹配

参考：！！！https://segmentfault.com/a/1190000015416513

> <font color='red'>***在mysql==建立==联合索引时会遵循最左前缀匹配的原则，即最左优先，在==检索==数据时从联合索引的最左边开始匹配***</font>

------

示例：
对列col1、列col2和列col3建一个联合索引

```sql
KEY test_col1_col2_col3 on test(col1,col2,col3);
```

联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。

```sql
SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”
```

上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。

------

### &sect; 引申

对于联合索引(col1,col2,col3)，查询语句SELECT * FROM test WHERE col2=2;是否能够触发索引？
大多数人都会说NO，实际上却是YES（<font color='red' size = 4>***前提是表中只有col1、col2、col3，如上建立的联合索引***</font>）。
**原因**：

```sql
EXPLAIN SELECT * FROM test WHERE col2=2;
EXPLAIN SELECT * FROM test WHERE col1=1;
```

观察上述两个==**explain**==结果中的type字段。查询中分别是：

1. ==**type: index**==
2. ==**type: ref**==

==**index**==：这种类型表示mysql会<font color='red'>**对整个该索引进行扫描**</font>。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个**联合索引的一部分**，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。
==**ref**==：<font color='red'>**这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，**</font>而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，**也就是索引字段的数据必须是<font color='red'>有序的</font>，才能实现这种类型的查找，才能利用到索引。**

------



### &sect; 为什么使用联合索引？

> ## **为什么要使用联合索引**
>
> - **减少开销**。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。**<font color='red'>每多一个索引，都会增加写操作的开销和磁盘空间的开销(I/O开销)</font>**。对于大量数据的表，使用联合索引会大大的减少开销！
> - **覆盖索引**。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。
> - **效率高**。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select *from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w*10%* 10% *10%=1w，效率提升可想而知！

------

## &sect; 索引失效情况

https://juejin.im/post/5d8dc96a6fb9a04e3b1107cd

<font color='red'>**explain + sql查看语句执行情况**</font>

### 针对普通索引：

> - **查询条件使用不等式**
> - **查询条件类型不一致**
> - **查询条件使用函数计算**
> - **模糊查询**

------

### 针对复合索引：

> - **查询条件使用不等式**
> - **查询条件类型不一致**
> - **查询条件使用函数计算**
> - **<font color='red'>不使用索引首列当查询条件</font>**

------

## &sect; sql查询优化方法

https://zhuanlan.zhihu.com/p/48385127

### 声明NOT NULL

当数据列被声明为NOT NULL以后，==在查询的时候就不需要判断是否为NULL，由于减少了判断，可以降低复杂性==，提高查询速度。

如果要表示数据列为空，可以使用0等代替。

### 考虑使用数值类型代替字符串

MySQL对数值类型的处理速度要远远快于字符串，而且数值类型往往更加节省空间。

例如对于“Male”和“Female”可以用“0”和“1”进行代替。

### 考虑使用ENUM类型

如果你的数据列的取值是确定有限的，可以使用ENUM类型代替字符串。<font color='red'>因为MySQL会把这些值表示为一系列对应的数字，这样处理的速度会提高很多。</font>

```java
CREATE TABLE shirts (
    name VARCHAR(40),
    size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
);

INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),
  ('polo shirt','small');

SELECT name, size FROM shirts WHERE size = 'medium';
```

------



## &sect; <font color='red'>索引使用原则</font>

> - <font color='red'>写操作频繁的列慎用索引</font>，因为写会带来B+树的维护操作，开销较大。
> - <font color='red'>索引是会占磁盘空间的</font>，要考虑。
> - <font color='red'>索引要加在维度大的列上</font>，及列的值不尽相同的那种，而不是列的值范围很小，重复很大。因为查询优化器发现根据该索引查询出的结果在全表的30%以上，即会跳过该索引，直接进行全表扫描
> - <font color='red'>建立索引的值要短小，这样一页可以放更多的索引，IO就会降低</font>

