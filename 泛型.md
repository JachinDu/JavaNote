# 泛型

参考：https://blog.csdn.net/s10461/article/details/53941091



## 0、特性

**<font color='red'>泛型只在编译阶段有效</font>**

```java
List<String> stringArrayList = new ArrayList<String>();
List<Integer> integerArrayList = new ArrayList<Integer>();

Class classStringArrayList = stringArrayList.getClass();
Class classIntegerArrayList = integerArrayList.getClass();

if(classStringArrayList.equals(classIntegerArrayList)){
    Log.d("泛型测试","类型相同");
}
```

输出：泛型测试","类型相同

通过上面的例子可以证明，<font color='red'>在编译之后程序会采取去泛型化的措施</font>。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。



## 1、泛型方法



```java
//定义泛型方法
public <K> void save(K k){/*<K>是定义了K这个类型，java中类型必须先定义后使用*/}

public <K,T> void save(T t, K k){/*使用两个泛型*/}

public <K,T> T save(T t, K k){/*使用两个泛型,返回值为泛型类*/}

// 可变参数
public <T> void printMsg( T... args){
    for(T t : args){
        Log.d("泛型测试","t is " + t);
    }
}
```

<mark>注意，泛型方法，若有返回类型，则返回类型其实由实际传入的对应参数的类型决定</mark>

####  静态方法的泛型：

静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<font color='red'>**静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。**</font>

<font color='red'>即：**如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法** 。</font>



## 2、泛型类

<mark>若一个类的多个方法都用到了泛型，即可将该类设计为泛型类，简化编程</mark>



```java
//定义泛型类
public class GenericDemo<T>{
	public <K> T save(T t, K k){/*由于泛型类只有T，所以这里还要保留K的定义<K>*/}
  public void update(T t){}
}

//使用
public void testMethod(){
  //创建泛型类对象，指定了类型
  GenericDemo<String> demo = new GenericDemo<String>();
  demo.save("test",1);//此处第一个参数已经默认为String类型了，第二个没有默认，依然为泛型，根据调用时传入的参数类型决定
}
```





## 3、泛型接口

在实现接口的类中指定类型，或者沿用泛型

```java
//定义泛型接口
public interface IBaseDao<T>{
  void save(T t);
}

//实现接口方式1
public class PersonDao implements IBaseDao<Person>{} //将对应类型传入
//实现接口方式2
public class BaseDao<T> implements IBaseDao<T>{}  //沿用泛型
```



## 4、泛型通配符

用来解决：<font color='red'>**同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的**。</font>如：

```java
Generic<Integer> gInteger = new Generic<Integer>(123);
Generic<Number> gNumber = new Generic<Number>(456);

showKeyValue(gInteger);

public void showKeyValue(Generic<Number> obj){
    Log.d("泛型测试","key value is " + obj.getKey());
}

// showKeyValue这个方法编译器会为我们报错：Generic<java.lang.Integer> 
// cannot be applied to Generic<java.lang.Number>
// showKeyValue(gInteger);
```



将上面的方法改为：

```java
public void showKeyValue(Generic<?> obj){
    Log.d("泛型测试","key value is " + obj.getKey());
}
```

类型通配符一般是使用`？`代替具体的类型==实参==，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而==不是类型形参== ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。

**<font color='red'>可见泛型通配符是用在“使用”时，而不是定义时。</font>**



**上下界通配符参考**：https://www.zhihu.com/question/20400700