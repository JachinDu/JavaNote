## tcp握手和挥手

参考：[https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络)

https://blog.csdn.net/qzcsu/article/details/72861891

## 0、TCP状态机

![image-20200216100609393](../PicSource/image-20200216100609393.png)

------



## 1、三次握手建立连接

tcp报文结构：

![image-20200312113032562](../PicSource/image-20200312113032562.png)



![三次握手](../PicSource/SouthEast-20200114194623938.png)

------

### 过程

> - 第一次握手：Client将SYN置1，<font color='red'>**随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；**</font>
> - 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，<font color='red'>**并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；**</font>
> - 第三次握手：<font color='red'>**客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。**</font>

------

### 各字段含义

> - **序列号seq**：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。
> - **确认号ack**：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。
> - **确认ACK**：<font color='red'>**占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效**</font>
> - **同步SYN**（synchronous）：<font color='red'>***连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。***</font>因此，SYN=1表示这是一个连接请求，或连接接受报文。<font color='red'>***SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。***</font>
> - **终止FIN**（finish）：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

------



### 为什么要三次握手？

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<font color='red'>双方确认自己与对方的发送与接收是正常的。</font>**

**第一次握手：Client 什么都不能确认；Server 确认了==对方发送正常，自己接收正常==**

**第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：==对方发送正常，自己接收正常==**

**第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：==自己发送、接收正常，对方发送、接收正常==**

**所以三次握手就能确认双发收发功能都正常，缺一不可。**

> **<font color='red'>若TCP三次握手第三次握手时ACK丢失怎么办？</font>**
>
> ​	**当Client端收到Server的SYN+ACK应答后，其状态变为ESTABLISHED，并发送ACK包给Server；** **<font color='red'>如果此时ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。</font>** 	
>

------



## 2、四次挥手断开连接



![四次挥手](../PicSource/SouthEast-20200114194804908.png)

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

------



### 为什么需要四次挥手？

**任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。**

------



### 为什么客户端最后还要等待2MSL？

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

- <font color='red'>***保证客户端发送的最后一个ACK报文能够到达服务器***</font>，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

- 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

------



### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， ==服务器在LISTEN状态下==，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，**<font color='red'>服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</font>**