# 线程的虚假唤醒

> <font color='gree' size=5>***主要是针对wait()方法***</font>

------



假设一个生产者/消费者的案例：需要两个消费者和一个生产者

```java
public class SpuriousWakeUp {

static Object lock = newObject();

static  int resourceNum = 0; // 资源数

public void getResource() {

  synchronized(lock) {
    while(resourceNum<=0) {
      // if (resourceNum<=0)则会虚假唤醒
      try{
      lock.wait();
      }catch(InterruptedException e) {
        e.printStackTrace();
      }
		}

	resourceNum--;

	System.out.println(Thread.currentThread().getName() +"获取资源成功");
	}
}

public void release() {

	synchronized(lock) {

		resourceNum++;

		lock.notify();

		System.out.println(Thread.currentThread().getName() +"释放资源成功");
	}
}}
```

------

> **若使用11行的if判断，假设消费者A，B都来获取资源，而此时资源数为0，则A，B都会进入wait()等待唤醒。此时生产者释放了一个单位的资源，并唤醒了A，A获取到了锁并获取到了资源，这时资源数再次变成了0，<font color='red'>*而由于存在虚假唤醒，在此同时有可能B也被唤醒，这时B会继续执行获取资源，出现错误，所以要用while来避免，这样即使出现了虚假唤醒，但仍需检查条件。*</font>**

