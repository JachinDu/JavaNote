# 进程与线程

<font color='gree' size=4>***进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；***</font>

------



## **程序**

是含有**<font color='red'>指令和数据</font>**的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。



## **进程**

> - 是程序的一次执行过程，是**<font color='red' size=4>*系统运行程序的基本单位*</font>**，因此进程是动态的。**<font color='red'>*系统运行一个程序即是一个进程从创建，运行到消亡的过程。*</font>**简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着。
>
> - 同时，**<font color='red'>每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等</font>**。换句话说，当程序在执行时，将会被操作系统载入内存中。 

------



## **线程**

与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是**<font color='red'>同类的多个线程==共享同一块内存空间和一组系统资源==，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</font>**

线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，**<font color='red'>进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</font>**

------



### &sect; 守护线程(Daemon)和用户线程(User)

> java中的线程分为两种：守护线程（Daemon）和用户线程（User）。
>
> 任何线程都可以设置为守护线程和用户线程，通过方法`Thread.setDaemon(bool on)`；true则把该线程设置为守护线程，反之则为用户线程。==**`Thread.setDaemon()`必须在Thread.start()之前调用，否则运行时会抛出异常。**==
>
> **两者的区别：** 
> 唯一的区别是判断虚拟机(JVM)何时离开，<font color='red'>**Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离**</font>。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；<font color='red'>**比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。**</font>
>
> 扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、==Finalizer守护进程==、引用处理守护进程、==GC守护进程==。

------

### &sect; 线程调度算法

> 计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.
>
> 有两种调度模型：分时调度模型和抢占式调度模型。 
>
> <font color='red'>***==分时调度模型==是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片***</font>。
>
> <font color='red'>***==java虚拟机采用抢占式调度模型==，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。***</font>

------

### &sect; 如何停止一个正在运行的线程？

> 1. <font color='purple'>***共享变量***</font>：当线程处于running状态中，可通过修改共享变量，时线程判断变量进行退出。
> 2. <font color='purple'>***interrupt***</font>：如果线程已被阻塞，就无法对共享变量进行判断，这时使用interrupt进行中断。

------

## 进程和线程的区别

> - <font color='purple'>***进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；***</font>
> - 线程依赖于进程而存在，一个进程至少有一个线程；
> - 进程有自己的独立地址空间，线程共享所属进程的地址空间；
> - 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；
> - <font color='purple'>***在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；***</font>
> - 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；
> - <font color='purple'>***多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮***</font>

------



## 四种==进程间==通信方式

https://www.jianshu.com/p/c1015f5ffa74

### 1.管道(pipe)

​    我们来看一条 Linux 的语句

```shell
netstat -tulnp | grep 8080
```

学过 Linux 命名的估计都懂这条语句的含义，其中<font color='gree'>***”|“是管道的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。***</font>在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种**管道**来进行通信了，并且我们可以知道这条**竖线**是没有名字的，所以我们把这种通信方式称之为==**匿名管道**==。

并且这种通信方式是==**单向**==的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。

居然有匿名管道，那也意味着有**命名**管道，下面我们来创建一个命名管道。

```shell
mkfifo  test
```

这条命令创建了一个名字为 test 的命名管道。

<font color='gree'>***接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。***</font>

```shell
echo "this is a pipe" > test   // 写数据
```

这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，<font color='red'>只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束</font>。接下来我们用另外一个进程来读取

```
cat < test  // 读数据
```

我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。

从上面的例子可以看出，管道的通知机制类似于**缓存**，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是**单向传输的。**

这种通信方式有什么缺点呢？显然，这种通信方式**效率低下**，你看，<font color='red'>a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</font>

所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，<font color='red'>**能够保证我们的数据已经真的被其他进程拿走了。==和SynchronousQueue一样==。**</font>我们平时用 Linux 的时候，也算是经常用。

------

### 2.消息队列

那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？

答是可以的，我们可以用**消息队列**的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的
消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于**缓存**吧。

这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味**发送消息（拷贝）**这个过程需要花很多时间来读内存。

哪有没有什么解决方案呢？答是有的，请继续往下看。

------



### 3.==共享内存==

​    **共享内存**这个通信方式就可以很好着解决**拷贝**所消耗的时间了。

这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？

我们都知道，系统加载一个进程的时候，==分配给进程的内存并不是**实际物理内存**，而是**虚拟内存空间**。==那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了**内存共享**机制了。==需要信号量来保证保证同步==

------

### 4.信号量(==用来控制多进程访问同一内存时如何协商==)

共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的**线程安全**问题。如何解决这个问题？这个时候我们的**信号量**就上场了。

<font color='red'>信号量的本质就是一个计数器(==像锁一样==），用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问**内存1**的时候，我们就把信号量的值设为 0，然后进程b 也要来访问**内存1**的时候，看到信号量的值为 0 就知道已经有进程在访问**内存1**了，这个时候进程 b 就会访问不了**内存1**。</font>所以说，信号量也是进程之间的一种通信方式。

------

### 5.Socket

上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？

答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。