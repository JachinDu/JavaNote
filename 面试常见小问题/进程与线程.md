# 进程与线程

<font color='gree' size=4>***进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；***</font>

------



## **程序**

是含有**<font color='red'>指令和数据</font>**的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。



## **进程**

> - 是程序的一次执行过程，是**<font color='red' size=4>*系统运行程序的基本单位*</font>**，因此进程是动态的。**<font color='red'>*系统运行一个程序即是一个进程从创建，运行到消亡的过程。*</font>**简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着。
>
> - 同时，**<font color='red'>每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等</font>**。换句话说，当程序在执行时，将会被操作系统载入内存中。 

------



## **线程**

与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是**<font color='red'>同类的多个线程==共享同一块内存空间和一组系统资源==，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</font>**

线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，**<font color='red'>进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</font>**

------



## 四种==进程间==通信方式

### 1.管道(pipe)

​    我们来看一条 Linux 的语句

```shell
netstat -tulnp | grep 8080
```

学过 Linux 命名的估计都懂这条语句的含义，其中<font color='gree'>***”|“是管道的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。***</font>在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种**管道**来进行通信了，并且我们可以知道这条**竖线**是没有名字的，所以我们把这种通信方式称之为==**匿名管道**==。

并且这种通信方式是==**单向**==的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。

居然有匿名管道，那也意味着有**命名**管道，下面我们来创建一个命名管道。

```shell
mkfifo  test
```

这条命令创建了一个名字为 test 的命名管道。

<font color='gree'>***接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。***</font>

```shell
echo "this is a pipe" > test   // 写数据
```

这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，<font color='red'>只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束</font>。接下来我们用另外一个进程来读取

```
cat < test  // 读数据
```

我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。

从上面的例子可以看出，管道的通知机制类似于**缓存**，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是**单向传输的。**

这种通信方式有什么缺点呢？显然，这种通信方式**效率低下**，你看，<font color='red'>a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</font>

所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，<font color='red'>**能够保证我们的数据已经真的被其他进程拿走了。==和SynchronousQueue一样==。**</font>我们平时用 Linux 的时候，也算是经常用。

------

### 2.消息队列

那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？

答是可以的，我们可以用**消息队列**的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的
消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于**缓存**吧。

这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味**发送消息（拷贝）**这个过程需要花很多时间来读内存。

哪有没有什么解决方案呢？答是有的，请继续往下看。

------



### 3.==共享内存==

​    **共享内存**这个通信方式就可以很好着解决**拷贝**所消耗的时间了。

这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？

我们都知道，系统加载一个进程的时候，==分配给进程的内存并不是**实际物理内存**，而是**虚拟内存空间**。==那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了**内存共享**机制了。

------

### 4.信号量(==用来控制多进程访问同一内存时如何协商==)

共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的**线程安全**问题。如何解决这个问题？这个时候我们的**信号量**就上场了。

<font color='red'>信号量的本质就是一个计数器(==像锁一样==），用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问**内存1**的时候，我们就把信号量的值设为 0，然后进程b 也要来访问**内存1**的时候，看到信号量的值为 0 就知道已经有进程在访问**内存1**了，这个时候进程 b 就会访问不了**内存1**。</font>所以说，信号量也是进程之间的一种通信方式。

------

### 5.Socket

上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？

答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。